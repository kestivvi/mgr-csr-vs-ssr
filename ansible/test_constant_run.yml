---
# ansible/test_constant_run.yml
#
# This playbook runs a single k6 load test on a target load generator.
# It is designed to be called by an external orchestrator script, which
# must provide all necessary variables via --extra-vars.
#
- name: Run k6 Load Test on a Single Generator
  hosts: "{{ target_host_group }}"
  become: true
  gather_facts: false

  vars:
    # --- Required variables to be passed by the orchestrator ---
    target_host_group: "undefined"
    target_url: "undefined"
    server_type: "undefined"
    prometheus_url: "undefined"
    k6_rate: 100
    k6_duration: "5m"
    k6_scenario: "constant_test"

    # --- Internal playbook variables ---
    local_k6_script_path: "../k6/script.js"
    remote_temp_script_path: "/tmp/script.js"
    container_name: "k6_test_{{ server_type | lower | replace('-', '_') }}"

  tasks:
    - name: Ensure k6 script exists locally before starting
      ansible.builtin.stat:
        path: "{{ local_k6_script_path }}"
      delegate_to: localhost
      run_once: true  # noqa: run-once[task]
      register: k6_script_file
      failed_when: not k6_script_file.stat.exists
      check_mode: false
      become: false

    - name: 1. Copy the raw k6 script to the remote host
      ansible.builtin.copy:
        src: "{{ local_k6_script_path }}"
        dest: "{{ remote_temp_script_path }}"
        mode: '0644'

    - name: Ensure any previous k6 test container is stopped and removed
      ansible.builtin.command: "docker rm -f {{ container_name }}"
      register: docker_rm_result
      failed_when: "docker_rm_result.rc != 0 and 'No such container' not in docker_rm_result.stderr"
      changed_when: "docker_rm_result.rc == 0"

    - name: Get start timestamp on remote host
      ansible.builtin.command: "date +%s"
      register: start_timestamp_result
      changed_when: false

    - name: Run k6 test by mounting the script file directly
      # noqa: command-instead-of-shell
      ansible.builtin.shell: >-
        docker run --rm
        --name {{ container_name }}
        --network host
        --ulimit nofile=250000:250000
        --volume {{ remote_temp_script_path }}:/test/script.js:ro,z
        -e K6_SCENARIO="{{ k6_scenario }}"
        -e SERVER_TYPE="{{ server_type | upper }}"
        -e TARGET_URL="{{ target_url }}"
        -e K6_RATE="{{ k6_rate | string }}"
        -e SCRIPT_DURATION="{{ k6_duration }}"
        -e K6_PROMETHEUS_RW_SERVER_URL="{{ prometheus_url }}/api/v1/write"
        -e K6_PROMETHEUS_RW_TREND_AS_NATIVE_HISTOGRAM="true"
        -e K6_LOG_OUTPUT="stdout"
        -e K6_BACKOFF_TIMEOUT_S="{{ k6_backoff_timeout_s | default(omit) }}"
        -e K6_BACKOFF_5XX_S="{{ k6_backoff_5xx_s | default(omit) }}"
        grafana/k6:latest
        run
        --out experimental-prometheus-rw
        --tag "server={{ server_type | upper }}"
        /test/script.js
      register: k6_run_result
      changed_when: true

    - name: Get end timestamp on remote host
      ansible.builtin.command: "date +%s"
      register: end_timestamp_result
      changed_when: false

    - name: Output precise timestamps for orchestrator
      ansible.builtin.debug:
        msg: "ORCHESTRATOR_TIMESTAMPS::{\"start\": \"{{ start_timestamp_result.stdout }}\", \"end\": \"{{ end_timestamp_result.stdout }}\"}"

    - name: Display k6 container logs for debugging
      ansible.builtin.debug:
        msg: "{{ k6_run_result.stdout_lines }}"

    - name: Clean up the remote script
      ansible.builtin.file:
        path: "{{ remote_temp_script_path }}"
        state: absent
